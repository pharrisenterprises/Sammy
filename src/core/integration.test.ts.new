/**
 * Core Module Integration Tests
 * @module core/integration.test
 * 
 * Tests the interaction between core modules to ensure they work
 * together correctly. Verifies type consistency, data flow, and
 * end-to-end workflows.
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

// Import from master barrel export to test public API
import {
  // Types
  type Step,
  type Project,
  type TestRun,
  type ParsedField,
  type LocatorBundle,
  createStep,
  createClickStep,
  createInputStep,
  createProject,
  createTestRun,
  createParsedField,
  createLocatorBundle,
  isValidStepEvent,
  isProjectComplete,
  calculatePassRate,
  
  // Storage
  type IStorageService,
  createStorageService,
  resetStorageService,
  
  // Replay
  type ExecutionContext,
  type StepExecutionResult,
  type SessionSummary,
  createReplayConfig,
  createReplayStateManager,
  resetReplayStateManager,
  ReplaySession,
  createReplaySession,
  createSingleRunSession,
  createDataDrivenSession,
  clearCurrentSession,
  DEFAULT_SESSION_CONFIG,
  
  // Orchestrator
  type OrchestratorConfig,
  type OrchestratorProgress,
  createTestOrchestrator,
  createMockTabManager,
  isTerminalState,
  isActiveState,
  calculateOverallProgress,
  
  // Background
  type BackgroundMessage,
  type BackgroundResponse,
  createMessageRouter,
  resetMessageRouter,
  createMockBackgroundTabManager,
  registerHandlers,
  createSuccessResponse,
  createErrorResponse,
  isStorageAction,
  isTabAction,
  getActionCategory,
  
  // CSV
  type CSVData,
  type FieldMapping,
  type CSVValidationResult,
  createCSVParser,
  createFieldMapper,
  createCSVValidator,
  createCSVProcessingService,
  createFieldMapping,
  createEmptyCSVData,
  normalizeString,
  diceSimilarity,
  isValidCSVData,
  hasValidMappings,
  getValidationSummary,
  formatRowCount,
  formatMappingStatus,
  formatConfidence,
  getConfidenceLevel,
  resetAllCSVSingletons,
  CSV_DEFAULTS,
  
  // Core utilities
  CORE_VERSION,
  ALL_DEFAULTS,
  resetAllSingletons,
} from './index';

// ============================================================================
// TEST UTILITIES
// ============================================================================

/**
 * Create a test locator bundle
 */
function createTestBundle(overrides?: Partial<LocatorBundle>): LocatorBundle {
  return createLocatorBundle({
    xpath: '//button[@id="submit"]',
    id: 'submit',
    tagName: 'BUTTON',
    ...overrides,
  });
}

/**
 * Create a test step
 */
function createTestStep(
  event: string = 'click',
  label: string = 'Test Button',
  value: string = ''
): Step {
  return createStep({
    event: event as Step['event'],
    label,
    value,
    path: '//button',
    selector: 'button#test',
    bundle: createTestBundle(),
  });
}

/**
 * Create a test project
 */
function createTestProject(overrides?: Partial<Project>): Project {
  return createProject({
    name: 'Test Project',
    target_url: 'https://example.com',
    description: 'Test description',
    ...overrides,
  });
}

/**
 * Create test CSV data
 */
function createTestCsvData(): Record<string, string>[] {
  return [
    { username: 'user1', password: 'pass1' },
    { username: 'user2', password: 'pass2' },
    { username: 'user3', password: 'pass3' },
  ];
}

/**
 * Create CSV content string
 */
function createCSVContent(
  headers: string[],
  rows: string[][]
): string {
  const headerLine = headers.join(',');
  const dataLines = rows.map(row => row.join(','));
  return [headerLine, ...dataLines].join('\n');
}

/**
 * Create test steps for CSV mapping
 */
function createInputSteps(): Step[] {
  return [
    createInputStep('First Name', '', createTestBundle({ id: 'firstName' })),
    createInputStep('Last Name', '', createTestBundle({ id: 'lastName' })),
    createInputStep('Email Address', '', createTestBundle({ id: 'email' })),
    createInputStep('Phone Number', '', createTestBundle({ id: 'phone' })),
  ];
}

// ============================================================================
// SETUP / TEARDOWN
// ============================================================================

beforeEach(() => {
  resetAllSingletons();
});

afterEach(() => {
  resetAllSingletons();
  vi.restoreAllMocks();
});

// ============================================================================
// TYPE INTEGRATION TESTS
// ============================================================================

describe('Type Integration', () => {
  describe('Step types flow through system', () => {
    it('should create step with valid event types', () => {
      const clickStep = createClickStep('Submit', createTestBundle());
      const inputStep = createInputStep('Username', 'testuser', createTestBundle());
      
      expect(isValidStepEvent(clickStep.event)).toBe(true);
      expect(isValidStepEvent(inputStep.event)).toBe(true);
      expect(clickStep.event).toBe('click');
      expect(inputStep.event).toBe('input');
    });
    
    it('should create project with steps array', () => {
      const steps: Step[] = [
        createClickStep('Button 1', createTestBundle()),
        createInputStep('Field 1', 'value', createTestBundle()),
      ];
      
      const project = createTestProject();
      project.recorded_steps = steps;
      
      expect(project.recorded_steps).toHaveLength(2);
      expect(project.recorded_steps[0].event).toBe('click');
      expect(project.recorded_steps[1].event).toBe('input');
    });
    
    it('should create test run with step results', () => {
      const testRun = createTestRun({
        project_id: 1,
        total_steps: 5,
        passed_steps: 4,
        failed_steps: 1,
      });
      
      expect(calculatePassRate(testRun)).toBe(80);
      expect(testRun.status).toBe('pending');
      
      testRun.status = 'completed';
      expect(testRun.status).toBe('completed');
    });
    
    it('should track project completion status', () => {
      const project = createTestProject();
      
      expect(isProjectComplete(project)).toBe(false);
      
      project.status = 'complete';
      expect(isProjectComplete(project)).toBe(true);
    });
  });
  
  describe('Field integrates with CSV data', () => {
    it('should create field mappings for CSV columns', () => {
      const csvData = createTestCsvData();
      const csvColumns = Object.keys(csvData[0]);
      
      const fields: ParsedField[] = csvColumns.map((col, index) => 
        createParsedField({
          original_label: col,
          mapped_label: col.charAt(0).toUpperCase() + col.slice(1),
          csv_column: col,
          mapped: true,
          step_index: index,
        })
      );
      
      expect(fields).toHaveLength(2);
      expect(fields[0].csv_column).toBe('username');
      expect(fields[1].csv_column).toBe('password');
    });
  });
  
  describe('LocatorBundle provides fallback options', () => {
    it('should identify best available locator', () => {
      const bundleWithId = createTestBundle({ id: 'unique-id' });
      const bundleWithXPath = createTestBundle({ id: undefined, xpath: '//div' });
      
      // Both should have valid locators
      expect(bundleWithId.id).toBe('unique-id');
      expect(bundleWithXPath.xpath).toBe('//div');
    });
  });
});

// ============================================================================
// REPLAY INTEGRATION TESTS
// ============================================================================

describe('Replay Integration', () => {
  describe('ReplaySession with Steps', () => {
    it('should create session with typed steps', () => {
      const steps: Step[] = [
        createClickStep('Login', createTestBundle()),
        createInputStep('Username', '', createTestBundle()),
        createInputStep('Password', '', createTestBundle()),
        createClickStep('Submit', createTestBundle()),
      ];
      
      const session = createReplaySession({
        steps,
        csvData: [],
      });
      
      expect(session.getLifecycle()).toBe('idle');
    });
    
    it('should create single-run session', () => {
      const steps: Step[] = [
        createTestStep('click', 'Button'),
      ];
      
      const session = createSingleRunSession(steps);
      
      expect(session.getLifecycle()).toBe('idle');
    });
    
    it('should create data-driven session with CSV', () => {
      const steps: Step[] = [
        createInputStep('Username', '', createTestBundle()),
        createInputStep('Password', '', createTestBundle()),
      ];
      
      const csvData = createTestCsvData();
      const fieldMappings = {
        username: 'Username',
        password: 'Password',
      };
      
      const session = createDataDrivenSession(steps, csvData, fieldMappings);
      
      expect(session.getLifecycle()).toBe('idle');
    });
  });
  
  describe('ExecutionContext with CSV values', () => {
    it('should build context with CSV data', () => {
      const csvRow = { username: 'testuser', email: 'test@example.com' };
      const fieldMappings = { username: 'Username Field', email: 'Email Field' };
      
      const context: ExecutionContext = {
        csvValues: csvRow,
        fieldMappings,
        variables: {},
      };
      
      expect(context.csvValues).toEqual(csvRow);
      expect(context.fieldMappings?.username).toBe('Username Field');
    });
  });
  
  describe('ReplayConfig presets', () => {
    it('should create config for different scenarios', () => {
      const fastConfig = createReplayConfig('fast');
      const tolerantConfig = createReplayConfig('tolerant');
      const debugConfig = createReplayConfig('debug');
      
      // Fast should have shorter timeouts
      expect(fastConfig.timing.findTimeout).toBeLessThan(
        tolerantConfig.timing.findTimeout
      );
      
      // Debug should enable visual feedback
      expect(debugConfig.visual.highlightElements).toBe(true);
    });
  });
  
  describe('ReplayStateManager tracks execution', () => {
    it('should manage lifecycle transitions', () => {
      const stateManager = createReplayStateManager();
      
      expect(stateManager.getLifecycle()).toBe('idle');
      
      stateManager.transitionTo('running');
      expect(stateManager.getLifecycle()).toBe('running');
      
      stateManager.transitionTo('paused');
      expect(stateManager.getLifecycle()).toBe('paused');
    });
    
    it('should track progress', () => {
      const stateManager = createReplayStateManager();
      
      stateManager.updateProgress({
        currentStep: 2,
        totalSteps: 10,
        passedSteps: 2,
        failedSteps: 0,
      });
      
      const progress = stateManager.getProgress();
      expect(progress.currentStep).toBe(2);
      expect(progress.percentage).toBe(20);
    });
  });
});

// ============================================================================
// ORCHESTRATOR INTEGRATION TESTS
// ============================================================================

describe('Orchestrator Integration', () => {
  describe('TestOrchestrator with MockTabManager', () => {
    it('should create orchestrator with tab manager', () => {
      const tabManager = createMockTabManager();
      const orchestrator = createTestOrchestrator(tabManager);
      
      expect(orchestrator.getLifecycle()).toBe('idle');
      expect(orchestrator.canStart()).toBe(false); // No project loaded
    });
    
    it('should track lifecycle states', () => {
      const tabManager = createMockTabManager();
      const orchestrator = createTestOrchestrator(tabManager);
      
      expect(isTerminalState(orchestrator.getLifecycle())).toBe(false);
      expect(isActiveState(orchestrator.getLifecycle())).toBe(false);
    });
  });
  
  describe('Progress calculation', () => {
    it('should calculate overall progress', () => {
      // 2 rows, 5 steps each, currently on row 1 step 3
      const progress = calculateOverallProgress(1, 2, 3, 5);
      
      // (1 * 5 + 3) / (2 * 5) * 100 = 8/10 * 100 = 80%
      expect(progress).toBe(80);
    });
    
    it('should handle edge cases', () => {
      expect(calculateOverallProgress(0, 0, 0, 0)).toBe(0);
      expect(calculateOverallProgress(0, 1, 0, 5)).toBe(0);
      expect(calculateOverallProgress(1, 1, 5, 5)).toBe(100);
    });
  });
  
  describe('MockTabManager operations', () => {
    it('should simulate tab lifecycle', async () => {
      const tabManager = createMockTabManager();
      
      // Open tab
      const result = await tabManager.openTab('https://example.com');
      expect(result.success).toBe(true);
      expect(result.tab).toBeDefined();
      
      // Check tab ready
      const ready = await tabManager.isTabReady(result.tab!.tabId);
      expect(ready).toBe(true);
      
      // Send message
      const response = await tabManager.sendMessage(result.tab!.tabId, { type: 'ping' });
      expect(response).toBe(true);
      
      // Close tab
      const closed = await tabManager.closeTab(result.tab!.tabId);
      expect(closed).toBe(true);
    });
  });
});

// ============================================================================
// BACKGROUND INTEGRATION TESTS
// ============================================================================

describe('Background Integration', () => {
  describe('MessageRouter with storage handlers', () => {
    it('should route storage actions to handlers', async () => {
      const router = createMessageRouter();
      const projects: Project[] = [];
      
      // Register storage handlers
      registerHandlers(router, {
        'add_project': async (message) => {
          const project = createTestProject(message.payload as Partial<Project>);
          project.id = projects.length + 1;
          projects.push(project);
          return createSuccessResponse({ id: project.id });
        },
        'get_all_projects': async () => {
          return createSuccessResponse({ projects });
        },
      });
      
      // Add project
      const addResponse = await router.route(
        { action: 'add_project', payload: { name: 'Test' } },
        { tab: { id: 1 } }
      );
      
      expect(addResponse.success).toBe(true);
      expect((addResponse as any).id).toBe(1);
      
      // Get all projects
      const getResponse = await router.route(
        { action: 'get_all_projects' },
        { tab: { id: 1 } }
      );
      
      expect(getResponse.success).toBe(true);
      expect((getResponse as any).projects).toHaveLength(1);
    });
    
    it('should categorize actions correctly', () => {
      expect(isStorageAction('add_project')).toBe(true);
      expect(isStorageAction('get_all_projects')).toBe(true);
      expect(isTabAction('openTab')).toBe(true);
      expect(getActionCategory('add_project')).toBe('storage');
      expect(getActionCategory('openTab')).toBe('tab');
    });
  });
  
  describe('BackgroundTabManager mock operations', () => {
    it('should track tabs with project association', async () => {
      const tabManager = createMockBackgroundTabManager();
      
      // Open tabs for different projects
      const tab1 = await tabManager.openTab('https://example.com', 1);
      const tab2 = await tabManager.openTab('https://example.org', 1);
      const tab3 = await tabManager.openTab('https://test.com', 2);
      
      expect(tab1.success).toBe(true);
      expect(tab2.success).toBe(true);
      expect(tab3.success).toBe(true);
      
      // Get tabs for project 1
      const projectTabs = tabManager.getTabsForProject(1);
      expect(projectTabs).toHaveLength(2);
      
      // Close project tabs
      const closed = await tabManager.closeProjectTabs(1);
      expect(closed).toBe(2);
      expect(tabManager.getTabsForProject(1)).toHaveLength(0);
      expect(tabManager.getTabsForProject(2)).toHaveLength(1);
    });
  });
  
  describe('Error handling', () => {
    it('should create error responses', () => {
      const errorFromString = createErrorResponse('Something went wrong');
      const errorFromError = createErrorResponse(new Error('Test error'));
      
      expect(errorFromString.success).toBe(false);
      expect(errorFromString.error).toBe('Something went wrong');
      expect(errorFromError.error).toBe('Test error');
    });
    
    it('should handle unknown actions', async () => {
      const router = createMessageRouter();
      
      const response = await router.route(
        { action: 'unknown_action' },
        { tab: { id: 1 } }
      );
      
      expect(response.success).toBe(false);
      expect(response.error).toContain('No handler');
    });
  });
});

// ============================================================================
// CSV INTEGRATION TESTS
// ============================================================================

describe('CSV Integration', () => {
  describe('CSVParser with type system', () => {
    it('should parse CSV to typed data structure', () => {
      const parser = createCSVParser();
      const content = createCSVContent(
        ['First Name', 'Last Name', 'Email'],
        [
          ['John', 'Doe', 'john@example.com'],
          ['Jane', 'Smith', 'jane@example.com'],
        ]
      );
      
      const result = parser.parseString(content);
      
      expect(result.success).toBe(true);
      expect(result.data?.headers).toEqual(['First Name', 'Last Name', 'Email']);
      expect(result.data?.rowCount).toBe(2);
      expect(result.data?.rows[0]['First Name']).toBe('John');
    });
    
    it('should validate parsed data structure', () => {
      const parser = createCSVParser();
      const content = createCSVContent(['Name'], [['Test']]);
      
      const result = parser.parseString(content);
      
      expect(isValidCSVData(result.data!)).toBe(true);
    });
    
    it('should handle empty CSV', () => {
      const parser = createCSVParser();
      
      const result = parser.parseString('');
      
      expect(result.success).toBe(false);
      expect(isValidCSVData(createEmptyCSVData())).toBe(false);
    });
  });
  
  describe('FieldMapper with Step types', () => {
    it('should auto-map CSV columns to step labels', () => {
      const mapper = createFieldMapper();
      const csvHeaders = ['First Name', 'Last Name', 'Email Address', 'Phone'];
      const steps = createInputSteps();
      
      const result = mapper.autoMap(csvHeaders, steps);
      
      // Should map matching columns
      expect(result.stats.mappedCount).toBeGreaterThan(0);
      
      // Check specific mappings
      const firstNameMapping = result.mappings.find(m => m.csvColumn === 'First Name');
      expect(firstNameMapping?.mapped).toBe(true);
      expect(firstNameMapping?.stepLabel).toBe('First Name');
    });
    
    it('should use similarity for fuzzy matching', () => {
      const mapper = createFieldMapper();
      
      // Exact match after normalization
      expect(mapper.getSimilarity('first_name', 'First Name')).toBe(1);
      
      // Partial match
      expect(mapper.getSimilarity('email', 'Email Address')).toBeGreaterThan(0.3);
      
      // No match
      expect(mapper.getSimilarity('xyz', 'abc')).toBe(0);
    });
    
    it('should convert mappings to ParsedField', () => {
      const mapper = createFieldMapper();
      const mappings: FieldMapping[] = [
        createFieldMapping('email', 'Email Address', {
          stepIndex: 2,
          confidence: 0.9,
          autoMapped: true,
        }),
        createFieldMapping('phone', null),
      ];
      
      const parsedFields = mapper.toParsedFields(mappings);
      
      expect(parsedFields).toHaveLength(2);
      expect(parsedFields[0].csv_column).toBe('email');
      expect(parsedFields[0].mapped).toBe(true);
      expect(parsedFields[1].mapped).toBe(false);
    });
  });
  
  describe('CSVValidator with data and mappings', () => {
    it('should validate data structure', () => {
      const validator = createCSVValidator();
      const parser = createCSVParser();
      
      const content = createCSVContent(
        ['Name', 'Email'],
        [['John', 'john@example.com']]
      );
      const parseResult = parser.parseString(content);
      
      const validation = validator.validateData(parseResult.data!);
      
      expect(validation.valid).toBe(true);
      expect(validation.stats.totalRows).toBe(1);
    });
    
    it('should validate mappings', () => {
      const validator = createCSVValidator();
      const parser = createCSVParser();
      
      const content = createCSVContent(['Name'], [['John']]);
      const parseResult = parser.parseString(content);
      const mappings = [createFieldMapping('Name', 'Full Name', { stepIndex: 0 })];
      
      const validation = validator.validateMappings(mappings, parseResult.data!);
      
      expect(validation.valid).toBe(true);
      expect(hasValidMappings(mappings, parseResult.data!)).toBe(true);
    });
    
    it('should detect validation errors', () => {
      const validator = createCSVValidator();
      const parser = createCSVParser();
      
      const content = createCSVContent(['Name'], [['John']]);
      const parseResult = parser.parseString(content);
      const mappings: FieldMapping[] = []; // No mappings
      
      const validation = validator.validateMappings(mappings, parseResult.data!);
      
      expect(validation.valid).toBe(false);
      expect(getValidationSummary(validation)).toContain('failed');
    });
  });
  
  describe('CSVProcessingService end-to-end', () => {
    it('should process CSV with auto-mapping', () => {
      const service = createCSVProcessingService();
      const content = createCSVContent(
        ['First Name', 'Last Name', 'Email Address'],
        [
          ['John', 'Doe', 'john@example.com'],
          ['Jane', 'Smith', 'jane@example.com'],
        ]
      );
      const steps = createInputSteps();
      
      const result = service.processContent(content, steps, 'users.csv');
      
      expect(result.parseResult.success).toBe(true);
      expect(result.mappings.length).toBeGreaterThan(0);
      expect(result.metadata.fileName).toBe('users.csv');
    });
    
    it('should track processing statistics', () => {
      const service = createCSVProcessingService();
      const content = createCSVContent(['Name'], [['A'], ['B'], ['C']]);
      const steps = createInputSteps();
      
      service.processContent(content, steps);
      
      const stats = service.getStats();
      
      expect(stats.filesProcessed).toBe(1);
      expect(stats.totalRowsParsed).toBe(3);
    });
  });
  
  describe('CSV utility functions', () => {
    it('should normalize strings consistently', () => {
      expect(normalizeString('First Name')).toBe('firstname');
      expect(normalizeString('first_name')).toBe('firstname');
      expect(normalizeString('FIRST-NAME')).toBe('firstname');
    });
    
    it('should calculate Dice similarity', () => {
      expect(diceSimilarity('hello', 'hello')).toBe(1);
      expect(diceSimilarity('abc', 'xyz')).toBe(0);
      expect(diceSimilarity('test', 'testing')).toBeGreaterThan(0);
    });
    
    it('should format display values', () => {
      expect(formatRowCount(0)).toBe('No rows');
      expect(formatRowCount(1)).toBe('1 row');
      expect(formatRowCount(100)).toBe('100 rows');
      expect(formatRowCount(1500)).toBe('1.5k rows');
      
      expect(formatMappingStatus(0, 5)).toBe('No columns mapped');
      expect(formatMappingStatus(5, 5)).toBe('All columns mapped');
      expect(formatMappingStatus(3, 5)).toBe('3 of 5 columns mapped');
      
      expect(formatConfidence(0.95)).toBe('95%');
      expect(formatConfidence(0.5)).toBe('50%');
      
      expect(getConfidenceLevel(0.8)).toBe('high');
      expect(getConfidenceLevel(0.5)).toBe('medium');
      expect(getConfidenceLevel(0.2)).toBe('low');
    });
  });
});

// ============================================================================
// END-TO-END WORKFLOW TESTS
// ============================================================================

describe('End-to-End Workflows', () => {
  describe('Recording → Storage → Replay flow', () => {
    it('should support full recording to replay workflow', async () => {
      // 1. Create project (simulating recording start)
      const project = createTestProject({
        name: 'E2E Test Project',
        target_url: 'https://example.com/form',
      });
      project.id = 1;
      
      // 2. Record steps (simulating user interactions)
      const recordedSteps: Step[] = [
        createInputStep('Username', '', createTestBundle({ id: 'username' })),
        createInputStep('Password', '', createTestBundle({ id: 'password' })),
        createClickStep('Login', createTestBundle({ id: 'login-btn' })),
      ];
      
      project.recorded_steps = recordedSteps;
      
      // 3. Define field mappings (CSV columns to step labels)
      const parsedFields: ParsedField[] = [
        createParsedField({
          original_label: 'Username',
          csv_column: 'user',
          mapped: true,
          step_index: 0,
        }),
        createParsedField({
          original_label: 'Password',
          csv_column: 'pass',
          mapped: true,
          step_index: 1,
        }),
      ];
      
      project.parsed_fields = parsedFields;
      
      // 4. Add CSV data
      const csvData: Record<string, string>[] = [
        { user: 'alice', pass: 'alice123' },
        { user: 'bob', pass: 'bob456' },
      ];
      
      project.csv_data = csvData;
      
      // 5. Verify project is ready for replay
      expect(project.recorded_steps).toHaveLength(3);
      expect(project.parsed_fields).toHaveLength(2);
      expect(project.csv_data).toHaveLength(2);
      
      // 6. Create replay session configuration
      const fieldMappings: Record<string, string> = {};
      for (const field of project.parsed_fields) {
        if (field.mapped && field.csv_column) {
          fieldMappings[field.csv_column] = field.original_label;
        }
      }
      
      expect(fieldMappings).toEqual({
        user: 'Username',
        pass: 'Password',
      });
      
      // 7. Create session (ready for execution)
      const session = createDataDrivenSession(
        project.recorded_steps,
        project.csv_data,
        fieldMappings
      );
      
      expect(session.getLifecycle()).toBe('idle');
    });
  });
  
  describe('CSV Import → Mapping → Replay flow', () => {
    it('should process CSV and prepare for replay', () => {
      // 1. Create processing service
      const csvService = createCSVProcessingService();
      
      // 2. Create steps (from recording)
      const steps: Step[] = [
        createInputStep('First Name', '', createTestBundle()),
        createInputStep('Last Name', '', createTestBundle()),
        createInputStep('Email', '', createTestBundle()),
      ];
      
      // 3. Create CSV content
      const csvContent = createCSVContent(
        ['first_name', 'last_name', 'email_address'],
        [
          ['John', 'Doe', 'john@example.com'],
          ['Jane', 'Smith', 'jane@example.com'],
        ]
      );
      
      // 4. Process CSV with auto-mapping
      const result = csvService.processContent(csvContent, steps);
      
      expect(result.parseResult.success).toBe(true);
      expect(result.validation.valid).toBe(true);
      
      // 5. Convert mappings to field mappings for replay
      const parsedFields = csvService.toParsedFields(result.mappings);
      
      // 6. Build field mapping lookup
      const fieldMappings: Record<string, string> = {};
      for (const mapping of result.mappings) {
        if (mapping.mapped && mapping.stepLabel) {
          fieldMappings[mapping.csvColumn] = mapping.stepLabel;
        }
      }
      
      // 7. Create replay session
      const session = createDataDrivenSession(
        steps,
        result.parseResult.data!.rows,
        fieldMappings
      );
      
      expect(session.getLifecycle()).toBe('idle');
    });
  });
  
  describe('Orchestrator → Tab → Replay coordination', () => {
    it('should coordinate tab management with replay', async () => {
      // 1. Create mock tab manager
      const tabManager = createMockTabManager();
      
      // 2. Create orchestrator
      const orchestrator = createTestOrchestrator(tabManager);
      
      // 3. Set up event tracking
      const events: string[] = [];
      
      orchestrator.onLifecycleChange((newState, prevState) => {
        events.push(`${prevState} → ${newState}`);
      });
      
      orchestrator.onLog((entry) => {
        events.push(`[${entry.level}] ${entry.message}`);
      });
      
      // 4. Verify initial state
      expect(orchestrator.getLifecycle()).toBe('idle');
      expect(orchestrator.getProject()).toBeNull();
      expect(orchestrator.getTab()).toBeNull();
      
      // 5. Verify tab manager is functional
      const tabResult = await tabManager.openTab('https://example.com');
      expect(tabResult.success).toBe(true);
      
      await tabManager.closeTab(tabResult.tab!.tabId);
    });
  });
  
  describe('Message routing → Storage coordination', () => {
    it('should route messages to storage operations', async () => {
      const router = createMessageRouter();
      const storage = new Map<number, Project>();
      let nextId = 1;
      
      // Register CRUD handlers
      registerHandlers(router, {
        'add_project': async (message) => {
          const project = createTestProject(message.payload as Partial<Project>);
          project.id = nextId++;
          storage.set(project.id, project);
          return createSuccessResponse({ id: project.id });
        },
        
        'get_project_by_id': async (message) => {
          const project = storage.get(message.id as number);
          if (project) {
            return createSuccessResponse({ project });
          }
          return createErrorResponse('Project not found');
        },
        
        'update_project_steps': async (message) => {
          const { id, recorded_steps } = message.payload as { id: number; recorded_steps: Step[] };
          const project = storage.get(id);
          if (project) {
            project.recorded_steps = recorded_steps;
            return createSuccessResponse();
          }
          return createErrorResponse('Project not found');
        },
        
        'delete_project': async (message) => {
          const deleted = storage.delete(message.id as number);
          return deleted 
            ? createSuccessResponse() 
            : createErrorResponse('Project not found');
        },
      });
      
      // Test CRUD flow
      const sender = { tab: { id: 1 } };
      
      // Create
      const createRes = await router.route(
        { action: 'add_project', payload: { name: 'CRUD Test' } },
        sender
      );
      expect(createRes.success).toBe(true);
      const projectId = (createRes as any).id;
      
      // Read
      const readRes = await router.route(
        { action: 'get_project_by_id', id: projectId },
        sender
      );
      expect(readRes.success).toBe(true);
      expect((readRes as any).project.name).toBe('CRUD Test');
      
      // Update
      const steps = [createClickStep('Test', createTestBundle())];
      const updateRes = await router.route(
        { action: 'update_project_steps', payload: { id: projectId, recorded_steps: steps } },
        sender
      );
      expect(updateRes.success).toBe(true);
      
      // Verify update
      const verifyRes = await router.route(
        { action: 'get_project_by_id', id: projectId },
        sender
      );
      expect((verifyRes as any).project.recorded_steps).toHaveLength(1);
      
      // Delete
      const deleteRes = await router.route(
        { action: 'delete_project', id: projectId },
        sender
      );
      expect(deleteRes.success).toBe(true);
      
      // Verify deletion
      const notFoundRes = await router.route(
        { action: 'get_project_by_id', id: projectId },
        sender
      );
      expect(notFoundRes.success).toBe(false);
    });
  });
});

// ============================================================================
// VERSION AND RESET TESTS
// ============================================================================

describe('Core Module Utilities', () => {
  it('should export version', () => {
    expect(CORE_VERSION).toBe('1.0.0');
  });
  
  it('should include all module defaults', () => {
    expect(ALL_DEFAULTS.storage).toBeDefined();
    expect(ALL_DEFAULTS.replay).toBeDefined();
    expect(ALL_DEFAULTS.orchestrator).toBeDefined();
    expect(ALL_DEFAULTS.background).toBeDefined();
    expect(ALL_DEFAULTS.csv).toBeDefined();
    
    // Verify CSV defaults
    expect(ALL_DEFAULTS.csv.similarityThreshold).toBe(0.3);
    expect(ALL_DEFAULTS.csv.previewRowCount).toBe(10);
  });
  
  it('should export CSV_DEFAULTS', () => {
    expect(CSV_DEFAULTS.SIMILARITY_THRESHOLD).toBe(0.3);
    expect(CSV_DEFAULTS.PREVIEW_ROW_COUNT).toBe(10);
    expect(CSV_DEFAULTS.MIN_MAPPED_FIELDS).toBe(1);
  });
  
  it('should reset all singletons including CSV', () => {
    // Create some state
    const router = createMessageRouter();
    router.register('test', async () => createSuccessResponse());
    
    const csvService = createCSVProcessingService();
    csvService.parseString('Name\nTest');
    
    // Reset
    resetAllSingletons();
    
    // Verify state is cleared (new instances would be created)
    expect(true).toBe(true); // If no errors, reset worked
  });
  
  it('should reset CSV singletons separately', () => {
    const csvService = createCSVProcessingService();
    csvService.parseString('Name\nTest');
    
    resetAllCSVSingletons();
    
    // If no errors, reset worked
    expect(true).toBe(true);
  });
});
